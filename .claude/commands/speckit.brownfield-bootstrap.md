---
description: Generate all preparation files required for SDD workflow for brownfield projects (existing projects), including constitution.md, template files, etc., enabling projects to immediately enter spec-driven development mode.
handoffs:
  - label: Create Feature Spec
    agent: /speckit.specify
    prompt: Create a new feature spec based on the project constitution. I want to build...
  - label: Verify SDD Ready Status
    agent: /speckit.analyze
    prompt: Verify the completeness and consistency of SDD preparation files
---

## User Input

```text
$ARGUMENTS
```

Before proceeding, you **must** consider the user input (if not empty).

---

# Brownfield Project SDD Bootstrap System

## Overview

This command is used to bring **existing projects (brownfield projects)** into the Specification-Driven Development (SDD) workflow. Unlike `specify init` which starts from scratch, this command will:

1. **Reverse-analyze** the existing codebase to extract architectural DNA
2. **Generate customized** project constitution (constitution.md) reflecting the project's actual principles
3. **Adapt templates** to the project's specific tech stack and coding style
4. **Verify readiness** to ensure SDD workflow can be immediately enabled

## âš ï¸ Critical: Target Directory Structure

> **ğŸš¨ Mandatory Constraint - Must Read**
>
> All files generated by this prompt **must and can only** use the following directory structure.
> **Any deviation will cause the spec-kit toolchain to fail**.
> Before generating any files, repeatedly confirm path correctness.

**Must strictly follow this directory structure**, which is a prerequisite for the spec-kit toolchain to work properly:

```
[Project Root]/
â”œâ”€â”€ .specify/                          # SDD configuration directory (toolchain depends on this path)
â”‚   â”œâ”€â”€ memory/
â”‚   â”‚   â””â”€â”€ constitution.md            # Project constitution (core file)
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”œâ”€â”€ spec-template.md           # Feature spec template
â”‚   â”‚   â”œâ”€â”€ plan-template.md           # Implementation plan template
â”‚   â”‚   â””â”€â”€ tasks-template.md          # Task list template
â”‚   â””â”€â”€ scripts/                       # Workflow scripts (optional, included in full installation)
â”‚       â”œâ”€â”€ bash/
â”‚       â””â”€â”€ pwsh/
â””â”€â”€ specs/                             # Feature spec working directory
    â””â”€â”€ [###-feature-name]/            # Organized by feature branch
        â”œâ”€â”€ spec.md
        â”œâ”€â”€ plan.md
        â””â”€â”€ tasks.md
```

**Important Notes**:
- `.specify/` directory name **must** start with a dot, not `specify/`
- Template files **must** be placed under `.specify/templates/`, not root `templates/`
- Constitution file **must** be at `.specify/memory/constitution.md`
- `specs/` directory is at root level, used to store spec files for each feature

### ğŸš¨ Mandatory Pre-Output Self-Check List

**Before outputting any files, must confirm all following checks pass:**

| # | Check Item | Correct âœ“ | Wrong âœ— | Verification Method |
|---|------------|-----------|---------|---------------------|
| 1 | Config directory name | `.specify/` | `specify/` | Must start with dot |
| 2 | Constitution file path | `.specify/memory/constitution.md` | `memory/constitution.md` | Must be under .specify |
| 3 | Template directory path | `.specify/templates/` | `templates/` | Must be under .specify |
| 4 | Specs directory path | `specs/` (root level) | `.specify/specs/` | Not under .specify |
| 5 | Template files complete | All 3 template files generated | Missing any template | spec/plan/tasks |

**âŒ If any check fails, must correct before output**

---

## Execution Flow

### Phase 0: Project Discovery

**Goal**: Systematically scan the project to extract core characteristics

#### Step 0.1: Structure Scan

First, perform a comprehensive project structure scan:

1. **Identify project root marker files**:
    - Package managers: `package.json`, `pom.xml`, `build.gradle`, `Cargo.toml`, `pyproject.toml`, `go.mod`, `Gemfile`, `composer.json`
    - Config files: `.editorconfig`, `.prettierrc`, `.eslintrc.*`, `tsconfig.json`, `tox.ini`, `setup.cfg`
    - Version control: `.git/`, `.gitignore`, `.gitattributes`
    - CI/CD: `.github/workflows/`, `.gitlab-ci.yml`, `Jenkinsfile`, `azure-pipelines.yml`
    - Containerization: `Dockerfile`, `docker-compose.yml`, `kubernetes/`

2. **Scan directory structure**:
   ```bash
   # Get project structure (depth 3 levels, exclude common ignore directories)
   find . -maxdepth 3 -type d \
     ! -path '*/node_modules/*' \
     ! -path '*/.git/*' \
     ! -path '*/vendor/*' \
     ! -path '*/__pycache__/*' \
     ! -path '*/target/*' \
     ! -path '*/build/*' \
     ! -path '*/dist/*' \
     -print
   ```

3. **Code distribution statistics**:
    - Identify primary programming languages (by file count and lines of code)
    - Identify test directory locations and testing frameworks
    - Identify documentation locations (docs/, README.*, CONTRIBUTING.md, etc.)

#### Step 0.2: Tech Stack Extraction

Based on scan results, build the tech stack profile:

```markdown
## Tech Stack Profile

**Primary Language**: [Identified primary language and version]
**Framework/Runtime**: [Identified main framework]
**Package Manager**: [Identified package management tool]
**Build Tool**: [Identified build system]
**Test Framework**: [Identified testing tool]
**Data Storage**: [Identified database/cache]
**Deployment Platform**: [Identified deployment target]
**CI/CD System**: [Identified CI/CD tool]
```

#### Step 0.3: Architecture Pattern Recognition

Analyze code structure to identify architectural patterns:

1. **Directory naming pattern analysis**:
    - `src/controllers/`, `src/handlers/` â†’ MVC/Layered Architecture
    - `src/domain/`, `src/application/`, `src/infrastructure/` â†’ Onion/Hexagonal Architecture
    - `services/`, `microservices/` â†’ Microservices Architecture
    - `modules/`, `packages/` â†’ Modular Monolith
    - `frontend/`, `backend/` â†’ Frontend-Backend Separation

2. **Code organization patterns**:
    - Feature-based organization
    - Layer-based organization
    - Domain-based organization

3. **Common pattern detection**:
    - Repository Pattern: `*Repository.*`, `*Repo.*`
    - Service Layer: `*Service.*`, `*Manager.*`
    - Factory Pattern: `*Factory.*`
    - DTO/VO: `*DTO.*`, `*VO.*`, `*Model.*`

#### Step 0.4: Coding Convention Extraction

Extract actual conventions from existing code:

1. **Extract from config files**:
    - ESLint/Prettier config â†’ JavaScript/TypeScript standards
    - .editorconfig â†’ General formatting standards
    - pylint/flake8/black config â†’ Python standards
    - checkstyle/spotless config â†’ Java standards

2. **Infer from code samples**:
    - Naming conventions (camelCase, snake_case, PascalCase)
    - File naming patterns (kebab-case.ts, PascalCase.java)
    - Comment style (JSDoc, docstring, Javadoc)
    - Import organization

3. **Infer from Git history** (optional):
    - Commit message format
    - Branch naming strategy
    - PR/MR templates

#### Step 0.5: Multi-Module/Multi-Subproject Analysis âš ï¸ Critical

**For projects containing multiple submodules (such as Java Maven/Gradle multi-module, Node.js Monorepo, etc.), this step is mandatory**.

##### 1. Identify Multi-Module Project Types

| Project Type | Identification Features | Identification Method |
|--------------|------------------------|----------------------|
| **Maven Multi-module** | Root `pom.xml` contains `<modules>` | Parse `<modules>` tag in `pom.xml` |
| **Gradle Multi-module** | Root `settings.gradle(.kts)` contains `include` | Parse `include` statements |
| **Node.js Monorepo** | Root `package.json` contains `workspaces` | Parse `workspaces` config |
| **Go Workspace** | `go.work` file exists | Parse `use` directives |
| **Rust Workspace** | `Cargo.toml` contains `[workspace]` | Parse `members` config |
| **Python Monorepo** | Multiple `pyproject.toml` or `setup.py` | Search for multiple package definition files |

##### 2. Enumerate All Submodules

**Must scan and list all submodules in the project**:

```markdown
## Submodule List

| Module Name | Path | Module Type | Packaging |
|-------------|------|-------------|-----------|
| [module-1] | [path/to/module-1] | [jar/war/pom/lib] | [artifact type] |
| [module-2] | [path/to/module-2] | [jar/war/pom/lib] | [artifact type] |
| ... | ... | ... | ... |
```

**Java Maven project example**:
```bash
# Parse parent pom.xml to get all submodules
grep -oP '(?<=<module>)[^<]+' pom.xml
```

**Java Gradle project example**:
```bash
# Parse settings.gradle to get all submodules
grep -oP "include\s*['\"]([^'\"]+)['\"]" settings.gradle
```

##### 3. Analyze Submodule Responsibilities

**Analyze and classify responsibilities for each submodule**:

| Module Category | Typical Naming Patterns | Responsibility Description |
|-----------------|------------------------|---------------------------|
| **API/Interface Layer** | `*-api`, `*-interface`, `*-facade` | External interface definitions, DTO/VO |
| **Service Implementation Layer** | `*-service`, `*-impl`, `*-core` | Business logic implementation |
| **Data Access Layer** | `*-dao`, `*-repository`, `*-persistence` | Database operations, Entity definitions |
| **Common Utility Layer** | `*-common`, `*-utils`, `*-base` | Shared utility classes, infrastructure |
| **Web/Controller Layer** | `*-web`, `*-controller`, `*-rest` | HTTP endpoints, request handling |
| **Bootstrap Module** | `*-app`, `*-boot`, `*-starter` | Application startup entry, configuration assembly |
| **Domain Module** | `*-domain`, `*-model` | Domain models, business entities |
| **Integration/Adapter** | `*-integration`, `*-adapter`, `*-client` | Third-party system integration |

**Generate Module Responsibility Mapping Table**:

```markdown
## Module Responsibility Mapping

| Module | Category | Core Responsibility | Allowed Code Types |
|--------|----------|--------------------|--------------------|
| user-api | API/Interface Layer | User service interface definitions | DTO, VO, Interface definitions, Enums |
| user-service | Service Implementation Layer | User business logic | Service implementations, business validation, transaction handling |
| user-dao | Data Access Layer | User data persistence | Entity, Repository, Mapper |
| common | Common Utility Layer | Shared infrastructure | Utility classes, constants, exception definitions |
```

##### 4. Analyze Inter-Module Dependencies

**Must analyze and document inter-module dependencies**:

**Maven project**:
```bash
# Analyze dependencies for each module
for module in $(grep -oP '(?<=<module>)[^<]+' pom.xml); do
  echo "=== $module ===" 
  grep -A1 '<dependency>' $module/pom.xml | grep -oP '(?<=<artifactId>)[^<]+'
done
```

**Generate Dependency Graph**:

```markdown
## Module Dependency Relationships

```
[app-boot]
â”œâ”€â”€ [user-service]
â”‚   â”œâ”€â”€ [user-api]
â”‚   â”œâ”€â”€ [user-dao]
â”‚   â””â”€â”€ [common]
â”œâ”€â”€ [order-service]
â”‚   â”œâ”€â”€ [order-api]
â”‚   â”œâ”€â”€ [order-dao]
â”‚   â”œâ”€â”€ [user-api]  â† Cross-module dependency
â”‚   â””â”€â”€ [common]
â””â”€â”€ [common]
```

### Dependency Rules

- **Allowed dependency direction**: Upper layer â†’ Lower layer (service â†’ api â†’ common)
- **Forbidden dependency direction**: Lower layer â†’ Upper layer, circular dependencies
- **Cross-domain dependencies**: Only through API module dependencies, no direct Service implementation dependencies
```

##### 5. Determine New Feature Code Placement Decision Tree

**Based on module analysis, create code placement decision guide**:

```markdown
## Code Placement Decision Tree

When adding new features, follow this decision tree to determine code location:

1. **Is this an externally exposed interface/DTO?**
   - Yes â†’ Place in corresponding domain's `*-api` module
   - No â†’ Continue

2. **Is this business logic/service implementation?**
   - Yes â†’ Place in corresponding domain's `*-service` module
   - No â†’ Continue

3. **Is this a database entity/data access?**
   - Yes â†’ Place in corresponding domain's `*-dao` module
   - No â†’ Continue

4. **Is this a utility shared across multiple domains?**
   - Yes â†’ Place in `common` module
   - No â†’ Continue

5. **Is this a new business domain?**
   - Yes â†’ Consider creating new module group (xxx-api, xxx-service, xxx-dao)
   - No â†’ Consult architect

### Module Selection Quick Reference

| Code Type | Target Module | Example |
|-----------|---------------|---------|
| New REST API | `[domain]-web` or `[domain]-controller` | UserController |
| New Service Interface | `[domain]-api` | IUserService |
| Service Implementation | `[domain]-service` | UserServiceImpl |
| Database Entity | `[domain]-dao` | UserEntity |
| Database Operations | `[domain]-dao` | UserRepository |
| DTO/VO | `[domain]-api` | UserDTO |
| Utility Class | `common` | StringUtils |
| Exception Definition | `common` or `[domain]-api` | UserNotFoundException |
| Configuration Class | `[domain]-boot` or `app` | DataSourceConfig |
```

---

### Phase 1: Constitution Generation

**Goal**: Generate project constitution based on project analysis

**Output File**: `.specify/memory/constitution.md`

#### Step 1.1: Create Directory Structure

First create necessary directories:

```bash
mkdir -p .specify/memory
mkdir -p .specify/templates
mkdir -p specs
```

#### Step 1.2: Principle Derivation

Based on the discovery report, derive principles the project should follow:

**Principle Derivation Logic**:

| Discovered Feature | Derived Principle | Principle Description |
|--------------------|-------------------|----------------------|
| Independent module/package structure exists | Modularity Principle | Features must be implemented as independent modules with clear boundaries |
| Unified test directory exists | Test-First Principle | All features must have tests written, tests before implementation |
| API directory/routes exist | Interface Contract Principle | All external interfaces must have contracts defined first |
| Uses specific framework | Framework Constraint Principle | Must use idiomatic patterns of [framework] |
| Unified error handling exists | Error Handling Principle | Errors must be handled through unified mechanism |
| Logging configuration exists | Observability Principle | All operations must produce traceable logs |
| CI/CD configuration exists | Continuous Integration Principle | All changes must pass automated verification |

#### Step 1.3: Generate Project Constitution

Create `.specify/memory/constitution.md`:

```markdown
# [PROJECT_NAME] Project Constitution

## Core Principles

### I. [PRINCIPLE_1_NAME]

[Principle description extracted from actual code patterns]

**Source**: [Explain which code feature this principle was derived from]
**Verification**: [How to verify code conforms to this principle]

### II. [PRINCIPLE_2_NAME]

[Principle description]

**Source**: [Derivation source]
**Verification**: [Verification method]

### III. Test Discipline (TDD Enforced)

âš ï¸ **TDD (Test-Driven Development) Enforced**

All new features must follow TDD Red-Green-Refactor cycle:
1. **ğŸ”´ Write test first**: Before any implementation code, there must be a failing test
2. **ğŸŸ¢ Minimal implementation**: Only write the minimum code to make the test pass
3. **ğŸ”µ Continuous refactoring**: Refactor after test passes, keep code clean

**Test Framework**: [Project's test framework]
**Test Location**: [Standard location for test code]
**Coverage Requirement**: New code â‰¥ 80%, core business logic 100%
**TDD Verification**: Can be verified through git commit history that tests precede implementation

### IV. Code Style

[Code style conventions extracted from project]

**Naming Convention**: [Project's naming conventions]
**Formatting**: [Project's formatting configuration]
**Toolchain**: [Code quality tools]

### V. Architectural Constraints

[Project's architectural boundaries and constraints]

**Architecture Style**: [Identified architecture style]
**Module Boundaries**: [Module division principles]
**Dependency Rules**: [Dependency management rules]

### VI. Code Reuse and Understanding Principles

#### No Code Duplication

**Mandatory Rule**: Before creating new classes and methods, **must** first search for existing classes and methods.

**Execution Steps**:
1. Search if similar functionality already exists in the project
2. Check component/common/utils/bll/service and other shared modules
3. Only create new code after confirming no reusable code exists

**Verification Method**: Check for duplicate implementations during code review

#### Understanding Existing Code

**Tool**: When understanding existing code is needed, use Repomix to generate/update skills for the project.

```bash
# Generate/update project skill documentation
repomix --skill-generate
```

**When to Use**:
- First time encountering the project
- Before major feature development or refactoring
- After significant changes to the codebase
- Before command `/speckit.specify`

## Tech Stack Anchoring

**SDD specs and plans for this project must follow this tech stack**:

| Category | Technology | Version Constraint | Non-replaceable |
|----------|------------|-------------------|-----------------|
| Language | [Language] | [Version] | âœ“ |
| Framework | [Framework] | [Version] | âœ“ |
| Testing | [Test Framework] | [Version] | âœ“ |
| Build | [Build Tool] | [Version] | âœ“ |

## Module Architecture *(Required for multi-module projects)*

### Project Type

**Project Structure**: [Single module/Multi-module Maven/Multi-module Gradle/Monorepo]
**Module Count**: [N] submodules

### Module List and Responsibilities

| Module Name | Path | Category | Core Responsibility | Allowed Code Types |
|-------------|------|----------|--------------------|--------------------|
| [module-api] | [path] | API/Interface Layer | [Responsibility description] | DTO, VO, Interface definitions |
| [module-service] | [path] | Service Implementation Layer | [Responsibility description] | Service implementations, business logic |
| [module-dao] | [path] | Data Access Layer | [Responsibility description] | Entity, Repository |
| [common] | [path] | Common Utility Layer | [Responsibility description] | Utility classes, constants |

### Module Dependency Relationships

```
[Dependency graph]
[app-boot]
â”œâ”€â”€ [xxx-service]
â”‚   â”œâ”€â”€ [xxx-api]
â”‚   â”œâ”€â”€ [xxx-dao]
â”‚   â””â”€â”€ [common]
â””â”€â”€ [common]
```

**Dependency Rules**:
- Allowed: [Upper layer module] â†’ [Lower layer module]
- Forbidden: Circular dependencies, cross-domain direct Service implementation dependencies
- Cross-domain: Only through API module dependencies

### New Feature Code Placement Decisions

| Code Type | Target Module | Target Path |
|-----------|---------------|-------------|
| New REST Interface | [web module] | [package path] |
| New Service Interface | [api module] | [package path] |
| Service Implementation | [service module] | [package path] |
| Database Entity | [dao module] | [package path] |
| DTO/VO | [api module] | [package path] |
| Utility Class | [common module] | [package path] |

## Directory Contract

**New code must be placed in locations conforming to these conventions**:

| Code Type | Standard Location | Naming Convention |
|-----------|-------------------|-------------------|
| Business Logic | [Path] | [Naming rule] |
| Data Model | [Path] | [Naming rule] |
| API Endpoint | [Path] | [Naming rule] |
| Test Code | [Path] | [Naming rule] |
| Config File | [Path] | [Naming rule] |

## Governance

### Constitution Priority

1. This constitution is the highest guidance for SDD workflow
2. All specs must conform to constitution principles
3. All plans must use constitution-anchored tech stack
4. All tasks must comply with directory contract

### Amendment Procedure

- Modifying the constitution requires documenting change reasons
- Must update all templates depending on this constitution
- Version numbers follow semantic versioning

**Version**: 1.0.0 | **Created**: [DATE] | **Source**: Brownfield Project Bootstrap
```

#### Step 1.4: User Confirmation

Present the generated constitution to user, request confirmation or modification:

```markdown
## Constitution Review

I have generated the project constitution based on project analysis. Please review the following key decisions:

### Principles to Confirm

1. **[Principle Name]**: [Principle Description]
   - ğŸ‘ Confirm / âœï¸ Modify / âŒ Delete

2. **[Principle Name]**: [Principle Description]
   - ğŸ‘ Confirm / âœï¸ Modify / âŒ Delete

### Technical Constraints to Confirm

- Is the primary language locked to [Language Version]?
- Is the test framework locked to [Test Framework]?
- Are there any missing key technologies?

### Directory Conventions to Confirm

Does the currently identified directory structure accurately reflect the code organization?

Please reply with confirmation or provide modification suggestions.
```

---

### Phase 2: Template Generation

**Goal**: Generate SDD templates adapted to project characteristics

**Input**: Phase 1 generated `.specify/memory/constitution.md`

#### Step 2.1: Generate Spec Template

Create `.specify/templates/spec-template.md`:

**Adaptation Points**:
- User story format fits project domain
- Acceptance criteria use formats verifiable by project test framework
- Requirement numbering follows project's existing numbering system (if any)

```markdown
# Feature Spec: [FEATURE NAME]

**Feature Branch**: `[###-feature-name]`
**Created**: [DATE]
**Status**: Draft
**Input**: User description: "$ARGUMENTS"

## User Scenarios and Tests *(Required)*

<!--
  Important Note: User stories should be sorted by importance, prioritized as user journeys.
  Each user story/journey must be independently testableâ€”meaning even if only one is implemented,
  you should still have a viable MVP (Minimum Viable Product) delivering value.

  Tech Stack Constraint: This project uses [Project Test Framework], acceptance scenarios must be expressible with that framework.
-->

### User Story 1 - [Brief Title] (Priority: P1)

[Describe this user journey in plain language]

**Priority Reason**: [Explain value and why this priority]

**Independent Testing**: [Describe how to verify using project's existing test facilities]

**Acceptance Scenarios**: 

1. **Given** [initial state], **When** [action], **Then** [expected result]
2. **Given** [initial state], **When** [action], **Then** [expected result]

---

### User Story 2 - [Brief Title] (Priority: P2)

[Describe this user journey in plain language]

**Priority Reason**: [Explain value and why this priority]

**Independent Testing**: [Describe how to test independently]

**Acceptance Scenarios**: 

1. **Given** [initial state], **When** [action], **Then** [expected result]

---

[Add more user stories as needed, each with assigned priority]

### Edge Cases

- What happens when [boundary condition]?
- How does system handle [error scenario]?

## Requirements *(Required)*

### Functional Requirements

- **FR-001**: System must [specific capability]
- **FR-002**: System must [specific capability]
- **FR-003**: User must be able to [key interaction]

*Example of marking unclear requirements:*

- **FR-00X**: System must [NEEDS CLARIFICATION: Unspecified requirement detail]

### Key Entities *(Include if feature involves data)*

- **[Entity 1]**: [What it represents, key attributes (no implementation details)]
- **[Entity 2]**: [What it represents, relationships with other entities]

## Integration Points with Existing System

**This feature needs to interact with the following existing modules**:

| Module | Path | Interaction Type | Interface Type |
|--------|------|------------------|----------------|
| [Existing Module] | [Path] | [Calls/Called by/Event] | [Interface Description] |

## Success Criteria *(Required)*

### Measurable Outcomes

- **SC-001**: [Measurable metric]
- **SC-002**: [Measurable metric]
```

#### Step 2.2: Generate Plan Template

Create `.specify/templates/plan-template.md`:

**Adaptation Points**:
- Technical background pre-filled with project tech stack
- Project structure reflects actual directory conventions
- Constitution checks reflect project constitution principles

```markdown
# Implementation Plan: [FEATURE]

**Branch**: `[###-feature-name]` | **Date**: [DATE] | **Spec**: specs/[###-feature-name]/spec.md

## Summary

[Feature requirements summary + technical implementation approach]

## Technical Background (Project Anchored)

âš ï¸ **The following tech stack is locked by project constitution, cannot be changed**:

**Language/Version**: [Project language and version]
**Main Framework**: [Project framework]
**Test Framework**: [Project test framework]
**Build Tool**: [Project build tool]
**Project Type**: [Monolith/Microservices/Monorepo]

## Constitution Compliance Check

*Must all pass before starting implementation*

- [ ] [Constitution Principle 1]: [Specific check item]
- [ ] [Constitution Principle 2]: [Specific check item]
- [ ] Directory Contract: All new file locations conform to constitution conventions
- [ ] Naming Convention: All naming conforms to project conventions

## Project Structure (Following Existing Conventions)

### New/Modified Files

```
[Project Root]
â”œâ”€â”€ [Existing directory structure]
â”‚   â””â”€â”€ [New files, using project naming conventions]
â””â”€â”€ [Test directory]
    â””â”€â”€ [New test files]
```

### Integration Points

| Existing Module | Location | Integration Method | Change Type |
|-----------------|----------|-------------------|-------------|
| [Module Name] | [Path] | [Method] | Add/Modify |

## Implementation Phases

### Phase 0: Verification and Preparation

- Confirm constitution checks pass
- Confirm no conflicts with existing code
- Confirm dependency version compatibility

### Phase 1: Core Implementation

[Implementation steps following project architecture patterns]

### Phase 2: Integration and Testing

[Test strategy using project test framework]
```

#### Step 2.3: Generate Tasks Template

Create `.specify/templates/tasks-template.md`:

**Adaptation Points**:
- Paths use project's actual directory structure
- Task descriptions use project naming conventions
- Test tasks use project test framework

```markdown
# Tasks: [FEATURE NAME]

**Feature Directory**: specs/[###-feature-name]/
**Prerequisites**: plan.md (required), spec.md (required)
**Constitution Constraints**: .specify/memory/constitution.md

## Path Conventions (Project Anchored)

âš ï¸ **The following paths are locked by project constitution**:

- **Business Code**: [Project business code path]
- **Data Model**: [Project model path]
- **Test Code**: [Project test path]
- **Config Files**: [Project config path]

## Phase 1: Setup and Verification

- [ ] T001 Verify constitution compliance checks
- [ ] T002 Confirm no naming conflicts with existing code
- [ ] T003 Confirm dependency version compatibility

## Phase 2: Infrastructure

**âš ï¸ Critical**: Only add necessary new dependencies, prefer reusing existing modules

- [ ] T004 [If needed] Add new dependencies in [Project dependency config]
- [ ] T005 [If needed] Create shared type/interface definitions

## Phase 3: User Story 1 - [Title] (P1)

### ğŸ”´ TDD Phase 1: Write Failing Tests

- [ ] T006 [P] Write tests in [Project test path]/[naming convention]
- [ ] T007 **Run tests, confirm failure** â† ğŸ”´ Must fail first

### ğŸŸ¢ TDD Phase 2: Minimal Implementation

- [ ] T008 [P] Create [component] in [Project code path]/[naming convention]
- [ ] T009 Implement **minimum code** to make tests pass
- [ ] T010 **Run tests, confirm passing** â† ğŸŸ¢ Must pass

### ğŸ”µ TDD Phase 3: Refactor

- [ ] T011 Refactor code, improve structure
- [ ] T012 **Run tests, confirm still passing** â† ğŸ”µ Must not break

**Checkpoint**: Run `[Project test command]` to verify

## Phase N: Integration Verification

- [ ] TXXX Run complete test suite: `[Project test command]`
- [ ] TXXX Run code checks: `[Project lint command]`
- [ ] TXXX Verify no regression with existing features
```

---

### Phase 3: Validation & Integration

**Goal**: Verify completeness and consistency of generated files, ensure SDD workflow can be immediately enabled

#### Step 3.1: Completeness Check

Verify all required files are generated:

```markdown
## SDD Readiness Checklist

### Directory Structure Verification

- [ ] `.specify/` directory created
- [ ] `.specify/memory/` directory created
- [ ] `.specify/templates/` directory created
- [ ] `specs/` directory created

### Core File Verification

- [ ] `.specify/memory/constitution.md` - Project Constitution âœ“
- [ ] `.specify/templates/spec-template.md` - Spec Template âœ“
- [ ] `.specify/templates/plan-template.md` - Plan Template âœ“
- [ ] `.specify/templates/tasks-template.md` - Tasks Template âœ“
```

#### Step 3.2: Consistency Verification

Verify reference consistency between files:

1. **Constitutionâ†”Template Consistency**:
    - Tech stack in templates matches constitution-locked tech stack
    - Path conventions in templates match constitution directory contract
    - Constitution check items in templates correspond to constitution principles

2. **Templateâ†”Template Consistency**:
    - Spec-template requirement format compatible with plan-template reference method
    - Plan-template phase division consistent with tasks-template task organization

3. **Templateâ†”Project Consistency**:
    - Paths in templates actually exist in project
    - Commands in templates can be executed in project

#### Step 3.3: Generate Acceptance Report

```markdown
## Brownfield Project SDD Bootstrap Completion Report

**Project**: [Project Name]
**Completion Time**: [Date]
**Bootstrap Status**: âœ… Success / âš ï¸ Manual Intervention Needed / âŒ Failed

### ğŸš¨ Output File Final Verification *(All must pass)*

| File | Expected Path | Actual Path | Verification Result |
|------|---------------|-------------|---------------------|
| Project Constitution | `.specify/memory/constitution.md` | [Fill actual path] | âœ…/âŒ |
| Spec Template | `.specify/templates/spec-template.md` | [Fill actual path] | âœ…/âŒ |
| Plan Template | `.specify/templates/plan-template.md` | [Fill actual path] | âœ…/âŒ |
| Tasks Template | `.specify/templates/tasks-template.md` | [Fill actual path] | âœ…/âŒ |

**âš ï¸ If any âŒ, must correct and re-output that file**

### Generated File List

| File | Path | Status | Notes |
|------|------|--------|-------|
| Project Constitution | `.specify/memory/constitution.md` | âœ… | Core file |
| Spec Template | `.specify/templates/spec-template.md` | âœ… | |
| Plan Template | `.specify/templates/plan-template.md` | âœ… | |
| Tasks Template | `.specify/templates/tasks-template.md` | âœ… | |
| Specs Directory | `specs/` | âœ… | Empty directory |

### Constitution Summary

**Core Principles**:
1. [Principle 1 Name]
2. [Principle 2 Name]
3. [Principle 3 Name]

**Tech Stack Locked**:
- Language: [Language]
- Framework: [Framework]
- Testing: [Test Framework]

### Next Steps

Project is ready to enter SDD workflow:

1. **Review Constitution**: Check `.specify/memory/constitution.md`, confirm constitution principles match project reality
2. **Start First Feature**: Use `/speckit.specify` or `specify` command to create first feature spec
3. **View Help**: Run `specify --help` to see all available commands

### Common Commands

```bash
# Create new feature branch and initialize spec
specify

# View current feature status
specify status

# Generate implementation plan
# Use /speckit.plan command

# Generate task list
# Use /speckit.tasks command
```

### Notes

- [Discovered potential issues]
- [Items requiring manual handling]
```

---

## ğŸ§ª TDD Test-Driven Development Discipline *(Mandatory)*

### TDD Core Principles

**All new feature development must strictly follow TDD Red-Green-Refactor cycle**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TDD Development Cycle (Mandatory)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. ğŸ”´ RED    â”‚ Write failing test â†’ Run tests â†’ Confirm failure     â”‚
â”‚  2. ğŸŸ¢ GREEN  â”‚ Write minimum code to pass â†’ Run tests â†’ Confirm pass â”‚
â”‚  3. ğŸ”µ REFACTOR â”‚ Refactor code â†’ Run tests â†’ Confirm still passing  â”‚
â”‚  4. ğŸ” REPEAT â”‚ Return to step 1, process next test case             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### TDD Execution Rules

| Rule | Description | Violation Consequence |
|------|-------------|----------------------|
| **Test before implementation** | Before writing any business code, corresponding failing test must exist | Code review failure |
| **Minimal implementation** | Only write minimum code to make current test pass | Avoid over-engineering |
| **Tests as documentation** | Test case naming must clearly describe business scenario | Poor maintainability |
| **100% new code coverage** | All new business logic must have corresponding tests | Cannot merge |

### TDD Position in SDD Workflow

```
Spec â†’ Plan â†’ Tasks â†’ [TDD Cycle] â†’ Complete
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Within each task:            â”‚
â”‚  T1: Write test case (ğŸ”´ expect failure)   â”‚
â”‚  T2: Run test, confirm failure â”‚
â”‚  T3: Implement feature code (ğŸŸ¢ minimal implementation) â”‚
â”‚  T4: Run test, confirm pass    â”‚
â”‚  T5: Refactor and optimize (ğŸ”µ keep tests passing) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### TDD Checkpoints *(Must verify after each user story implementation)*

- [ ] All acceptance scenarios have corresponding test cases
- [ ] Tests exist before implementation code (verifiable via git history)
- [ ] Test case naming clearly expresses business intent
- [ ] New code test coverage â‰¥ 80% (core business logic 100%)
- [ ] All tests pass before code commit

---

## General Guidelines

### Brownfield Project Special Considerations

1. **Respect existing architecture**: Don't try to "improve" existing architecture, accurately reflect it
2. **Tech stack lock**: Brownfield project tech stack is established fact, constitution must anchor it
3. **Gradual introduction**: SDD workflow should seamlessly integrate into existing development process
4. **Compatibility first**: All generated code must be consistent with existing code style
5. **No code duplication**: Before creating new classes and methods, must first search for existing ones, only create new code if nothing reusable exists
6. **Understand existing code**: When understanding existing code is needed, use Repomix to generate/update skills for the project, command: `repomix --skill-generate`

### Path Reference Standards

**When referencing other files in template files**:

| Reference Target | Correct Path | Wrong Path |
|------------------|--------------|------------|
| Project Constitution | `.specify/memory/constitution.md` | `memory/constitution.md` |
| Spec Template | `.specify/templates/spec-template.md` | `templates/spec-template.md` |
| Feature Spec | `specs/[###-feature]/spec.md` | `.specify/specs/[###-feature]/spec.md` |

### Handling Uncertainty

When certain conventions cannot be determined from code:

1. **Prefer industry standards**: Best practices based on tech stack
2. **Mark for confirmation**: Use `[NEEDS CLARIFICATION: Question description]` to mark
3. **Limit quantity**: Maximum 3 items to be confirmed
4. **Provide options**: Provide 2-3 suggested options for each item to be confirmed

### Error Handling

| Scenario | Handling Approach |
|----------|-------------------|
| Cannot identify project type | Ask user to confirm primary tech stack |
| Abnormal directory structure | Use standard structure but mark as "non-standard project" |
| No test code | Add "Establish testing practices" principle in constitution |
| Multi-language project | Identify primary language, list all languages in constitution |

---

## Context

{ARGS}
